module Variable where

import Numeric.Natural
import Data.List (intercalate)
import Data.Int
import Control.Lens
import Types

data Id where
  Id :: String -> Natural -> Id
  deriving (Eq, Ord)

idNat :: Lens' Id Natural
idNat = lens
  (\(Id _   i)   -> i)
  (\(Id str _) i -> Id str i)

instance Show Id where
  show (Id str i) = "%" ++ str ++ "_" ++ show i
--   show (Variable name i) = "%" ++ name  ++ "_" ++ show i

data V a where
  (:::) :: Id -> Ty a → V a

instance Show (V a) where
  show (name ::: ty) = "%" ++ show name ++ subscript ty

data Ex f where
  Ex :: f x -> Ex f

ex :: (forall x. f x -> r) -> Ex f -> r
ex f (Ex fa) = f fa

-- type Name = Ex V

variableType' :: Lens (V a) (V b) (Ty a) (Ty b)
variableType' = 
  lens 
    (\(_    ::: ty)    -> ty)
    (\(name ::: _ ) ty -> name ::: ty)

variableName' :: Lens' (V a) String
variableName' = 
  lens 
    (\(Id str _ ::: _)      -> str) 
    (\(Id _   i ::: ty) str -> Id str i ::: ty)

variableNat' :: Lens' (V a) Natural
variableNat' = 
  lens 
    (\(Id _   i ::: _)    -> i)
    (\(Id str _ ::: ty) i -> Id str i ::: ty)

-- | Variables, the unique part is their 'Natural' identifier, this
-- way variables constructed when going from a higher- to a
-- first-order representation won't care about the variable names:
-- only their number.

-- | Variables along with their name and identifier.
-- The identifier should be unique after a pass from 'makeFresh'.
-- data Name
--   = Variable String Natural
--   deriving (Eq, Ord)

-- variableNat :: Lens' Name Natural
-- variableNat = 
--   lens 
--     (\(Variable _   n)   -> n) 
--     (\(Variable str _) n -> Variable str n)

-- | Variable from converting HOAS to a first-order representation:
--    lam (\x -> x + x)
-- => Lam (Lambda 1) (Add (Var (Lambda 1)) (Var (Lambda 1)))
-- == Lam (Var "lam" 1) (Add (Var (V "lam" 1)) (Var (V "lam" 1)))
-- 
-- This is generated from a different source than other variables so
-- they are prefaced with "lam".
pattern Lambda ∷ Natural → Id
pattern Lambda ident = Id "λ" ident

pattern Lambda2 ∷ GetTy ty _rep => Natural -> V ty
pattern Lambda2 ident <- Id "λ" ident ::: _     where
        Lambda2 ident =  Id "λ" ident ::: getTy

-- -- | Getting the identifier from a variable.
pattern VarId ∷ Natural → Id
pattern VarId ident ← Id _ ident

data Label 
  = Label String Natural
  deriving (Eq, Ord)

instance Show Label where
  show (Label name i) = name ++ "_" ++ show i

-- | An Operand is roughly that which is an argument to an
-- instruction, it gets generated by the 'compile' function, this way
-- you can either return variables (registers) or return constant
-- values.

data Op
  = Reference Id
  | Undef String
  | ConstTru
  | ConstFls
  | ConstNum8  Int8
  | ConstNum32 Int32
  | Struct [Op]

instance Show Op where
  show = \case
    Reference a → show a
    Undef ty     → ty ++ " undef"
    ConstTru     → "true"
    ConstFls     → "false"
    ConstNum8 i  → show i
    ConstNum32 i → show i
    Struct flds  → "{" ++ intercalate ", " (map format flds) ++ "}" where
      format ∷ Op → String
      format (Reference n)  = "i32 " ++ "%" ++ show n
      format (Undef ty)     = ty ++ " undef"
      format ConstTru       = "i1 true"
      format ConstFls       = "i1 false"
      format (ConstNum8 i)  = "i8 " ++ show i
      format (ConstNum32 i) = "i32 " ++ show i
      format (Struct str)   = show str

-- Lenses

-- class HasVars s t a b | s → a, t → b, s b → t, t a → s where
--   var ∷ Traversal s t a b
--   default var ∷ (Traversable f, HasVars s t a b) 
--               ⇒ Traversal (f s) (f t) a b
--   var = traverseOf (traverse.var)

-- instance HasVars (VarName id) (VarName id') id id' where
--   --  ∶ Traversal' Name Natural
--   var ∷ Traversal (VarName id) (VarName id') id id'
--   var f (Variable name id) = Variable <$> pure name <*> f id

-- instance HasVars Label Label Natural Natural where
--   --  ∶ Traversal' Name Natural
--   var ∷ Traversal' Label Natural
--   var f (Label name id) = Label <$> pure name <*> f id


