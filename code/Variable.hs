{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE KindSignatures, TypeApplications, DataKinds, StandaloneDeriving #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE ExplicitNamespaces #-}
{-# LANGUAGE UnicodeSyntax, RankNTypes, LambdaCase #-}
{-# LANGUAGE UndecidableInstances, AllowAmbiguousTypes #-}

{-# LANGUAGE FlexibleInstances, TypeFamilyDependencies, ConstraintKinds, BangPatterns, DataKinds, DeriveDataTypeable, DeriveFoldable, DeriveFunctor, DeriveGeneric, DeriveTraversable #-}
{-# LANGUAGE DefaultSignatures, DisambiguateRecordFields, EmptyCase, FunctionalDependencies, GADTs, GeneralizedNewtypeDeriving, InstanceSigs, ImplicitParams #-}
{-# LANGUAGE ImpredicativeTypes, LambdaCase, LiberalTypeSynonyms, MagicHash, MultiParamTypeClasses, MultiWayIf, MonadComprehensions, NamedFieldPuns #-}
{-# LANGUAGE NamedWildCards, NumDecimals, NoMonomorphismRestriction, ParallelListComp, PartialTypeSignatures, PatternSynonyms, PolyKinds, PostfixOperators #-}
{-# LANGUAGE RankNTypes, RecordWildCards, RecursiveDo, RoleAnnotations, ScopedTypeVariables, StandaloneDeriving, TemplateHaskell, TupleSections #-}
{-# LANGUAGE TypeFamilies, TypeOperators, UnboxedTuples, UnicodeSyntax, ViewPatterns, QuasiQuotes, TypeInType, ApplicativeDo #-}

module Variable where

import Numeric.Natural
import Data.List (intercalate)
import Data.Int
import Control.Lens
import Types
import Util

data Id where
  Id :: String -> Natural -> Id
  deriving (Eq, Ord)

getId :: V a ◃Lens'▹ Id
getId = lens
  (\(id ::: _) -> id)
  (\(_ ::: ty) id -> id ::: ty)

idNat :: Id ◃Lens'▹ Natural
idNat = lens
  (\(Id _   i)   -> i)
  (\(Id str _) i -> Id str i)

instance Show Id where
  show (Id str i) = "%" ++ str ++ "_" ++ show i
--   show (Variable name i) = "%" ++ name  ++ "_" ++ show i

data V a where
  (:::) :: Id -> Ty a → V a

type Arg = Ex V

instance Show (V a) where
  show (name ::: ty) = show name ++ subscript ty

toLLVMVar :: ∀a. V a -> String
toLLVMVar (name ::: ty) = toLLVMType ty ++ " " ++ show name

data Ex f where
  Ex :: f x -> Ex f

ex :: (forall x. f x -> r) -> Ex f -> r
ex f (Ex fa) = f fa

-- | Variables, the unique part is their 'Natural' identifier, this
-- way variables constructed when going from a higher- to a
-- first-order representation won't care about the variable names:
-- only their number.

-- | Variables along with their name and identifier.
-- The identifier should be unique after a pass from 'makeFresh'.
-- data Name
--   = Variable String Natural
--   deriving (Eq, Ord)

-- variableNat :: Name ◃Lens'▹ Natural
-- variableNat = 
--   lens 
--     (\(Variable _   n)   -> n) 
--     (\(Variable str _) n -> Variable str n)

-- | Variable from converting HOAS to a first-order representation:
--    lam (\x -> x + x)
-- => Lam (Lambda 1) (Add (Var (Lambda 1)) (Var (Lambda 1)))
-- == Lam (Var "lam" 1) (Add (Var (V "lam" 1)) (Var (V "lam" 1)))
-- 
-- This is generated from a different source than other variables so
-- they are prefaced with "lam".
pattern Lambda ∷ Natural → Id
pattern Lambda ident = Id "λ" ident

pattern Lambda2 ∷ GetTy ty => Natural -> V ty
pattern Lambda2 ident <- Id "λ" ident ::: _     where
        Lambda2 ident =  Id "λ" ident ::: getTy

-- -- | Getting the identifier from a variable.
pattern VarId ∷ Natural → Id
pattern VarId ident ← Id _ ident

data Label 
  = Label String Natural
  deriving (Eq, Ord)

instance Show Label where
  show (Label name i) = name ++ "_" ++ show i

-- | An Operand is roughly that which is an argument to an
-- instruction, it gets generated by the 'compile' function, this way
-- you can either return variables (registers) or return constant
-- values.

data Op
  = Reference Id
  | Undef String
  | ConstTru
  | ConstFls
  | ConstNum8 Int8
  | ConstNum  Int
  | Struct [Op]
  deriving (Eq)

instance Show Op where
  show = \case
    Reference a → show a
    Undef ty    → ty ++ " undef"
    ConstTru    → "true"
    ConstFls    → "false"
    ConstNum8 i → show i
    ConstNum  i → show i
    Struct flds  → "{" ++ intercalate ", " (map format flds) ++ "}" where
      format ∷ Op → String
      format (Reference n) = "i32 " ++ "%" ++ show n
      format (Undef ty)    = ty ++ " undef"
      format ConstTru      = "i1 true"
      format ConstFls      = "i1 false"
      format (ConstNum8 i) = "i8 " ++ show i
      format (ConstNum i)  = "i32 " ++ show i
      format (Struct str)  = show str

-- Lenses

-- class HasVars s t a b | s → a, t → b, s b → t, t a → s where
--   var ∷ Traversal s t a b
--   default var ∷ (Traversable f, HasVars s t a b) 
--               ⇒ Traversal (f s) (f t) a b
--   var = traverseOf (traverse.var)

-- instance HasVars (VarName id) (VarName id') id id' where
--   --  ∶ Traversal' Name Natural
--   var ∷ Traversal (VarName id) (VarName id') id id'
--   var f (Variable name id) = Variable <$> pure name <*> f id

-- instance HasVars Label Label Natural Natural where
--   --  ∶ Traversal' Name Natural
--   var ∷ Traversal' Label Natural
--   var f (Label name id) = Label <$> pure name <*> f id


variableType' :: Lens (V a) (V b) (Ty a) (Ty b)
variableType' = 
  lens 
    (\(_    ::: ty)    -> ty)
    (\(name ::: _ ) ty -> name ::: ty)

variableName' :: Lens' (V a) String
variableName' = 
  lens 
    (\(Id str _ ::: _)      -> str) 
    (\(Id _   i ::: ty) str -> Id str i ::: ty)

variableNat' :: Lens' (V a) Natural
variableNat' = 
  lens 
    (\(Id _   i ::: _)    -> i)
    (\(Id str _ ::: ty) i -> Id str i ::: ty)

